- 区块链技术6：拜占庭将军问题

- 本篇主要结合Lamport（（2013年的图灵奖得主） 1982年的论文《Byzantine Generals Problem》讲一讲拜占庭将军问题（Byzantine Generals Problem），本质上，它是分布式系统的一致性问题。区块链最重要的特点就是分布式系统，去中心化，那么在这个系统中同样地存在一致性问题。

- 为了理解什么是一致性问题，看一下下面的图。

- ![img](https://pic4.zhimg.com/80/v2-6736f5d8c558a176cd27418665ffbfef_720w.jpg)

- 在中心化系统中，中心点负责传达消息，只要中心点不出错，系统就能够正常运行。譬如，银行负责记账，用户只负责交易和查询。但是，正如我们之前看到的，中心点是可能出问题的。

- 而非中心化系统中，各个节点之间如何达成一致呢？在货币系统中，如果有用户花了钱又不肯认帐怎么办？有恶意攻击者故意捣乱怎么办？这就是分布式系统的一致性问题。

- （一）拜占庭问题

- 以下定义来自维基百科：拜占庭将军问题重定向到拜占庭容错。

- 拜占庭容错（BFT）是容错计算机系统，特别是分布式计算系统的可靠性问题，其中组件可能发生故障并且关于组件是否发生故障的信息不完整。在“拜占庭式故障”中，诸如服务器之类的组件对故障检测系统可能不一致地出现故障和起作用两种情况，向不同的观察者呈现不同的状况。

- 其他组件很难将其声明失败并将其关闭，因为他们需要首先就哪个组件失败达成共识。所以的组件必须就协同战略达成一致，以避免灾难性的系统失败，但有些组件不可靠。拜占庭容错也被称为交互一致性或源一致性、错误雪崩、拜占庭协议问题、拜占庭将军问题和拜占庭失败。

- 至于为什么会叫做“拜占庭将军问题”，分布式系统的大牛Lamport给出了一段说明：

- [https://www.microsoft.com/en-us/research/publication/byzantine-generals-problem/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Flamport%2Fpubs%2Fbyz.pdfwww.microsoft.com](https://link.zhihu.com/?target=https%3A//www.microsoft.com/en-us/research/publication/byzantine-generals-problem/%3Ffrom%3Dhttp%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Flamport%2Fpubs%2Fbyz.pdf)

- 简而言之就是说，Lamport觉得在并发领域，哲学家吃饭问题（The Philosopher's Eating Problem）获得的关注比读者-写者问题（Reader-Writer Problem）大多了，虽然读者-写者问题的用处明显很大一些。Lamport的结论就是，给一个研究性的问题起一个故事性的名字对引起关注有好处。

- 之前有过“Two Generals Problem（Chinese Generals Problem）”，主要是研究不安全的链路上进行通信和协调的情况。所以Lamport就参考了这个题目，也起了个将军的名字。

- 所以，听起来神秘高大上的拜占庭问题，也就是在分布式系统中的一个共识问题。用计算机的术语来说，就是一个多主机的系统如何处理一个或者多个组件失效的问题。这个有10台主机的系统，需要有所有的主机互相通信，必须要一半以上的主机就一个问题达成一致。但是有的主机坏掉了，以至于向其他主机发送信息时出现错误。那共识问题时，当有主机失效时，其他的主机能达成一致吗？

- 当这个共识问题的主机换成将军就容易理解多了。

- 拜占庭帝国想要进攻一个城市，为此派出了10个将军率领10支军队，这个城市足以抵御5支常规拜占庭军队的同时袭击。这10支军队不能集合在一起单点突破，必须在分开的包围状态下同时攻击，至少6支军队同时袭击才能攻下敌国。10支军队分散在敌国的四周，依靠通信兵相互通信来协商进攻意向及进攻时间。这里的问题是，对应于有的主机坏掉了，将军中可能会有叛徒，忠诚的将军希望达成命令的一致（比如约定某个时间一起进攻），但背叛的将军会通过发送错误的消息阻挠忠诚的将军达成命令上的一致。在这种状态下，拜占庭将军们能否找到一种分布式的协议来让他们能够远程协商，从而赢取战斗？

- 当前研究的结论是：如果叛徒的数量大于或等于1/3，拜占庭问题不可解。

- 先看4个将军A、B、C、D的情况，假设4个将军中最多只有1个背叛者。如果超过一半的将军，也即3个将军去进攻，能取得胜利。

- （1）假设A将军分别告诉B、C、D将军，下午1点发起进攻。假设B、C、D中有一人是叛徒。那么，到了下午1点，将有三个将军发起进攻，同时他们能发现发现没有参与进攻的将军是叛徒。在这种情况中，对任务执行没有影响。

- （2）假设如果A是背叛的，A分别告诉B、C、D将军在下午1点、2点、3点发起进攻。于是，到了下午，B、C、D三个将军分别去进攻，都失败了。这种情况下，对任务是毁灭性打击。

- 为了防止出现这种情况，对于忠诚的将军来说，他不能完全相信接收到的命令，所以必须对命令做出判断。

- 在1999年，出现了著名的PBFT算法，PBFT是Practical Byzantine Fault Tolerance的缩写，意为实用拜占庭容错算法，由Miguel Castro (卡斯特罗)和Barbara Liskov（利斯科夫）提出（之所以叫做Practical，是因为这个算法解决了之前的BFT算法效率低下的问题，将算法复杂度从指数级将为多项式级）。这个算法的核心思想是：对于每一个收到命令的将军，都要去询问其他人，他们收到的命令是什么。

- （1）对于上面的第一种情况，假设B、C、D中的B是叛徒。在A告诉B、C、D下午1点进攻时，B、C、D三人之间会有一次信息交互，它们会分别把自己收到的信息告诉给另外两人。此时不管B发出的时间是多少，C和D两人之中都会得到至少两个是1点的消息，也即【1点（来自A），？点（来自B），1点（来自D）】和【1点（来自A），？点（来自B），1点（来自C）】。这种情况下，1点是占多数的信息。对于C和D而言，此时不能判断谁是叛徒（如果A是叛徒，但是发给C和D 1点；而发给B ？点）。但是不管怎么样，C和D都能放心执行1点进攻的命令。

- - 对于C和D而言，如果A是叛徒，那么B会收到来自C和D的两条1点进攻的消息，所以B、C和D都会在1点发起进攻；忠诚的将军获胜；
  - 对于C和D而言，如果B是叛徒，那么A、C和D将会同时在1点发起进攻；忠诚的将军获胜。

- （2）对于上面的第二种情况，A是背叛者的情况，在A告诉B、C、D三个不同的时间之后，B、C、D三人之间会有一次信息交互，它们会分别把自己收到的信息告诉给另外两人。在这种情况下，B会收到【1点（来自A），2点（来自C），3点（来自D）】三个不同的时间，C同样会收到三个不同的时间【1点（来自B），2点（来自A），3点（来自D）】，以及D会收到【1点（来自B），2点（来自C），3点（来自A）】。

- 这样，在叛徒数不超过三分之一的情况下，也即B、C、D都知道最多只有一个叛徒的情况下，三人都能判断出A是叛徒。

- 那么，如果叛徒数达到或者超过1/3呢？

- 譬如对于3个将军的情况，3个将军A、B、C，其中一人是叛徒。假设将军A发出进攻命令“下午1点进攻”，B或C其中一人是叛徒。假设B是叛徒，他可能告诉C，他收到的是“下午两点进攻”的命令。这时C收到一个“下午一点进攻”，一个“下午两点进攻“，因此C不能判断谁是叛徒，也不能判断真正的进攻时间。 另一种情况是，如果A是叛徒，告诉B“在下午1点进攻”，告诉C“在下午2点进攻”。当B告诉C，他收到“在下午1点进攻”的命令时，C收到的是“在下午两点进攻”的命令，同样无法判断进攻的时间和真正的叛徒。 从上面的例子可以看出，在只有三个将军的系统中，只要有一个是叛徒，也即1/3，拜占庭问题便不可解。

- 以上的讨论主要是对应于一种情况：所有传递的消息都是口头消息。口头消息和书写消息的不同是，消息的接收方无法判断消息的正确性。例如，在B是叛徒的情况下，即使A告诉B要“下午1点进攻”，B可以篡改消息成“A告诉我要下午2点进攻”。此时C和D无法判断到底是A还是B在撒谎。

- 另一种考虑的情况是：消息传递采用书写的形式。在这里，书写意味着A可以使用特殊的笔迹或者在命令上加盖自己的印章，而笔迹或者印章是不可伪造的。那么问题可以简化为A将军用写下的“下午1点进攻”消息，加盖印章，然后传给B，因为有印章，所以B无法篡改A的消息，同时在纸上加盖自己的印章，然后把这张纸传给C，C也加盖印章表示同意，然后D也加盖印章，最后加盖了4个印章的纸再传给没人看一遍，就可以让所有节点一致了。这使得问题大大简化，但采用书面消息的前提是：每个将军都知道其他将军的笔迹或印章，并且笔迹或印章无法被模仿，其他将军也容易进行认证；在一次通信中，各个将军是顺序签名的，如果所有的将军同时发消息，那么消息量会大大增加。

- （二）区块链一致性

- 对于区块链而言，笔迹或印章的条件是满足的。

- 相当于每个将军配备一台电脑（相当于分布式的节点），降低了信息流通成本，让信息可以及时地同步到各位将军。而每个人都有一对公私钥，使用私钥进行签名，其他用户使用公钥进行认证。也即，从理论而言，区块链是可以以书写的的方法达到一致性。

- 同时在限制消息数量的问题上，区块链创新性地引入PoW共识算法，通过工作量证明，增加了发送信息的成本，降低节点发送消息速率，使得一次只有一个用户可以发出消息；同时在广播时会附上自己的签名。类似于将军A向其他的将军（B、C、D…）发起一个提议，将军B、C、D…看到将军A签过名的进攻提议书，诚实的将军在经过验证之后，就会同意进攻提议，而不会发起自己新的进攻提议；如果其中发现错误，才会发起自己的进攻提议。

- 使用区块链语言描述，当一个矿工打包出一个区块之后，其他节点会对这个区块进行验证。如果验证通过，则表明已经有节点发布新区块成功，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争。网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。

- 假如打包的节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。

- 工作量证明其实相当于提高了做叛徒（发布虚假区块）的成本，在工作量证明下，只有第一个完成证明的节点才能广播区块，竞争难度非常大，需要很高的算力，如果不成功其算力就白白的耗费了（算力是需要成本的），如果有这样的算力作为诚实的节点，同样也可以获得很大的收益（这就是矿工所作的工作），这也实际就不会有做叛徒的动机，整个系统也因此而更稳定。

- （三）两军问题

- 最后顺便说一下两军问题。

- ![img](https://pic3.zhimg.com/80/v2-5d8eb4d5e7b14d95461930a1f97ac08a_720w.jpg)

- wikipedia

- 蓝军（B）驻扎在山谷之中，红军分两部分驻扎在山谷两旁（A1, A2）。A1和A2需要同时进攻才能击败蓝军。为了约定共同进攻的时间，A1派出通信兵将攻击时间传达给A2，但通信兵需要穿过山谷才能将攻击时间传达给A2。而这个过程中，通信兵极有可能被蓝军截获从而导致A2不知道A1的进攻时间，于是A1不能确定进攻时间。

- 如果A2收到了进攻时间，为了和A1确定，A2在收到A1的信息之后也派出通信兵将自己受到的消息传给A1。然而，A2的通信兵同样可能被拦截。于是A2也也不确定A1是否知道自己的进攻时间。

- A1收到A2的消息，可以发出第三条消息，对A2做确认或者发现消息被篡改。但是，这又开始新的不确定过程。从而形成了无限循环，双方始终不能对进攻时间达成一致。

- 这个问题虽然形式上拜占庭将军很像，但是本质上这两个问题是不同的。拜占庭将军问题描述的是可靠信道上的多主体共识问题；而两军问题描述的是不可靠信道上的共识问题，也没有叛徒，更类似于TCP的三次握手。TCP三次握手通过加上序列号，确保对消息的确认，但是第三条消息能否被收到，发送方同样无法确认，也只是在成本和效率之间取得的折中。

- 实际上，两军问题是第一个被证明是无解的计算机通信问题。

- 可以用反证法证明：假如存在某种方法，使得通信之后，红军可以达成一致发起进攻。那么红军的两支军队的通信中最后一条信息要么是必要的，要么不是。如果是，接着向下证明；如果不是，可以删除它，直到剩下的每条信息都是必要的。在所有这些必要的通信中，如果最后一条消息没有安全到达目的地，则会怎样呢？因为所有的消息都是必要的，所以如果这一条丢了，发送方就不敢发动进攻，从而不能达成一致性。

- 而拜占庭问题，在以上描述的两种情况中，在满足一定条件的情况下，是可以达到一致性的。

- 参考：

- [区块链研习 | 看懂“拜占庭容错”，也就看懂了区块链的核心技术www.leiphone.com](https://link.zhihu.com/?target=https%3A//www.leiphone.com/news/201709/YAd57zwnq8C1IGc2.html)

  


