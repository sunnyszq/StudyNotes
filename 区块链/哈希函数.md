### 哈希函数  

> 什么是哈希函数
>
> 哈希函数：可以把任意长度的输入转换成固定长度的输出，也就是哈希值。例如SHA-256输出256bit，同时也是比特币用的哈希函数。
>
>  

哈希函数特点

1. 确定性   相同的消息产生的哈希值相同

2. 快速计算  可以快速计算任何给定的哈希值

3. 隐藏性hiding   直到哈希值后不能倒推出输入信息

   应用：commitment（承诺）、数据库保存用户的账号和密码时为了安全起见将信息进行哈希，来保证用户数据安全，另外在注册时密码有数字、字母等组合要求也是为了使哈希值更安全。

4. 抗冲突：理想状态下，找到具有相同散列值的两个不同消息是不可行的。不可能找到两个x和y，x！=y，而H(x)=H(y)。

   抗冲突应用：信息摘要message digest

5. 雪崩效应：对消息进行很小的改动如更改一个标点符号，就会引起哈希值发生变化，且变化后的哈希值与原来哈希值看起来毫不相干。

6.  puzzle friendliness

   对于每一个可能的 n 位输出 y ，如果k是随机性很强的值（譬如长度为256位的随机二进制串），那么找到一个合适的x使得 ![[公式]](https://www.zhihu.com/equation?tex=H%28k%7C%7Cx%29%3Dy) 是不可能显著地低于 ![[公式]](https://www.zhihu.com/equation?tex=2%5En) 的时间复杂度。

   注意k||x,不是概率上的意思，是在x后加上k字符串等信息

   这个特点强调的是，如果给定特殊的哈希结果 ![[公式]](https://www.zhihu.com/equation?tex=y) ，并且输入中有一部分随机性很强 ![[公式]](https://www.zhihu.com/equation?tex=k) ，那么找到输入的另一个部分 ![[公式]](https://www.zhihu.com/equation?tex=x) 使得哈希的结果等于y，那么就只能依靠暴力搜索。

   应用： search puzzle ；区块链中的工作量证明。

### SHA-256

> SHA-256是SHA-2中的一个算法。SHA-2，也即第二代安全散列算法（Secure Hash Algorithm 2），由美国国家安全局2001年公布的标准哈希算法，是SHA-1的后继。SHA-2下包括六个不同的算法标准：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。这些不同的算法使用不同生成摘要的长度 、循环运行的次数，但算法的基本结构是一致的。现在已知SHA-2容易受到长度扩展攻击，所以推荐使用SHA-3来取代它。
>
> **对于任意长度的消息，SHA256都产生256bit长的哈希值，也即32字节，或者64位的16进制数，或者8个8位的16机制数 。**



SHA-256计算过程：

![preview](https://pic3.zhimg.com/v2-109d2371c4ef8095fb10f628a68dc29b_r.jpg)

![img](https://pic1.zhimg.com/80/v2-ad361062a640ff9911d84d71517988fa_720w.jpg)



A-H共有八个，一个4B=32b 总共8×32=256位，有初始值是前八个素数（2,3,5,7,11,13,17,19）取平方根换成二进制再取前32位，然后转换成16进制，因此初始值是8个16进制数。最终生成的哈希值也是8个16进制数，通过每一轮的运算进行更新。每一轮计算64次，除了A-H外，还有两个输入，分别是wt和kt，也即每一轮中有64个![[公式]](https://www.zhihu.com/equation?tex=w)，以及64个![[公式]](https://www.zhihu.com/equation?tex=k)。每个![[公式]](https://www.zhihu.com/equation?tex=w)长度为32bit（与A~H中的一个相当），也即4B。64个![[公式]](https://www.zhihu.com/equation?tex=w)来自于哈希函数的输入，也即，对于输入，不论长短，长的就分成每512bit一个块（64个字节），短的补足512bit。这64个字节构成了前16个![[公式]](https://www.zhihu.com/equation?tex=w)（每个有4B，总共16个，4B*16=64B刚好构成一块），后面的48个![[公式]](https://www.zhihu.com/equation?tex=w)通过前面的16个生成。

```go
for i from 16 to 63
        s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3)
        s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10)
        w[i] := w[i-16] + s0 + w[i-7] + s1
```



64个k是64个常量，这些常量是对自然数中前64个质数(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…)的立方根的小数部分取前32bit而来。

然后每一次的计算，基本思想：就是将消息分成N个512bit的数据块，哈希初值H(0)经过第一个数据块得到H（1），H（1）经过第二个数据块得到H（2），……，依次处理，最后得到H（N），然后将H（N）的8个32bit连接成256bit消息摘要.

h := g
g := f
f := e
e := d **+** temp1
d := c
c := b
b := a
a := temp1 **+** temp2

### 信息预处理(pre-processing)

SHA256算法中的预处理就是在想要Hash的消息后面补充需要的信息，使整个消息满足指定的结构。

信息的预处理分为两个步骤：`附加填充比特`和`附加长度`

> 注意：信息必须进行填充，填充的具体过程：先补第一个比特为1，然后都补0，直到长度满足对512取模后余数是448。即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512个比特。因此，填充是至少补一位，最多补512位。
>
> 为什么是448?
>
> 因为在第一步的预处理后，第二步会再附加上一个64bit的数据，用来表示原始报文的长度信息。而448+64=512，正好拼成了一个完整的结构。



### SHA-256在区块链中的应用

哈希在区块链中的用处包括：

1. 利用puzzle-friendliness的工作量证明，也即，要求生成一个新区块时，哈希值一定要是以一定数量的连续的0开始的；
2. 对每个区块的内容进行哈希，后面的区块相当于一直在对前面的区块进行哈希，所以一般来说，如果一个区块之后如果跟上其他6个区块之后，一般认为该区块的内容已经被公认了，不可更改。



参考：

[区块链技术4：密码学之哈希](https://zhuanlan.zhihu.com/p/44544072)

[SHA256算法原理详解](https://blog.csdn.net/u011583927/article/details/80905740)