#### 分治

分治就是分而治之，将一个大问题，拆分成若干个子问题，求解出子问题后，合并。

分治通常使用递归来进行，写分治其实就是在写递归

[分治代码模板](https://shimo.im/docs/3xvghYh3JJPKwdvt)

```java
Java
private static int divide_conquer(Problem problem, ) {
  
  if (problem == NULL) {
    int res = process_last_result();
    return res;     
  }
  subProblems = split_problem(problem)
  
  res0 = divide_conquer(subProblems[0])
  res1 = divide_conquer(subProblems[1])
  
  result = process_result(res0, res1);
  
  return result;
}
```

-------

例子：

https://leetcode-cn.com/problems/powx-n/

```java
实现 pow(x, n) ，即计算 x 的 n 次幂函数。

示例 1:

输入: 2.00000, 10
输出: 1024.00000
示例 2:

输入: 2.10000, 3
输出: 9.26100
示例 3:

输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
说明:

-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
```



![image-20201212165443865](https://gitee.com/sunnyzq/my-image-hosting-service/raw/master/img//image-20201212165443865.png)

**分治步骤（结合递归模板）：**

> 1.terminator 判断终止条件
>
> 2.process (split your big problem) 在分治中主要就是分解问题
>
> 3.drill down (subproblems) 调用递归解决子问题
>
> 4.merge(subresult)  合并子问题的解
>
> 5.reverse states  

在求解n次幂的时候，重要的就是分解子问题：

```java
class Solution {
    //快速幂就是分治思想  
    //分治 + 迭代法
    public double myPow(double x, int n) {
        if(n == 0) return 1.0;
        double res = 1.0;
        
        for(int i = n;i != 0; i /= 2) {
            //如果是奇数
            if(i % 2 != 0) {
                res *= x;
            }
            //i是偶数
            x *= x;
        }
        
        return n > 0 ? res : 1.0/res;
    }
}
```

时间复杂度 O(logn)

空间复杂度 O(logn) 递归深度

```java
class Solution {
    public double myPow(double x, int n) {
        if(n == 0) return 1.0;
        double res = 1.0;
        
        for(int i = n;i != 0; i /= 2) {
            //如果是奇数
            if(i % 2 != 0) {
                res *= x;
            }
            //i是偶数
            x *= x;
        }

        return n > 0 ? res : 1.0/res;
    }
}
```



-----

## 参考链接

- [牛顿迭代法原理](http://www.matrix67.com/blog/archives/361)
- [牛顿迭代法代码](http://www.voidcn.com/article/p-eudisdmk-zm.html)

