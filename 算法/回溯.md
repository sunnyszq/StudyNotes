### 回溯

回溯算法框架

```text
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**我们只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。

##### 剪枝

> 由于回溯算法的时间复杂度很高，因此，在遍历的时候，如果能够提前知道这一条分支不能搜索到满意的结果，这一分支就可以跳过，这一步操作就是在一棵树上剪去一个枝叶，被人们很形象地称之为**剪枝**。

![img](https://gitee.com/sunnyzq/my-image-hosting-service/raw/master/img//2020070114210076.png)

例题：

[括号生成问题](https://leetcode-cn.com/problems/generate-parentheses/)

```java
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

 

示例：

输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
    
//使用回溯方法
    
```

1.做加法

初始：左括号和右括号数量为0。
过程：

- 什么时候可以添加左括号？---「左括号当前数量」 小于 「n」
- 什么时候可以添加右括号？---「右括号当前数量」 小于 「左括号当前数量」
- （若右括号当前数量已经大于左括号当前数量，那么无论你怎样添加右括号都不可能和左括号数量匹配）
- 结束：总共可以添加n个左括号和n个右括号。

> 注意：
>
> 如果在每一个 「非叶子结点」 分支的尝试，都创建 「新的变量」 表示状态，那么在回到上一层结点的时候不需要「回溯」；在递归终止的时候也不需要做拷贝。
> 由于java字符串变量在拼接的过程中会产生新的对象，因此这里不需要回溯

```java

class Solution {
    public List<String> generateParenthesis(int n) {
        //回溯方法
        List<String> res = new ArrayList<>();
        String sb = "";
        dfs(0,0,n,res,sb);
        return res;
    }

    public void dfs(int left,int right,int n,List<String> res,String sb) {
        //判断满足条件
        //或者    if(sb.length() == 2 * n)
        if(left == n && right == n) {
            res.add(sb);
            return;
        }

        if(left < right) return;      //剪枝
        if(left < n) {
            dfs(left+1,right,n,res,sb + "(");     
            //由于java字符串变量在拼接过程中会产生新的对象，因此这里不需撤销选择(回溯)
            //这是因为String是final的，不可改变，每次都需要产生新的对象

        }
        if(right < left) {
            dfs(left,right+1,n,res,sb + ")");
             //由于java字符串变量在拼接过程中会产生新的对象，因此这里不需撤销选择(回溯)
        }
    }
}
```

标准的回溯算法，不适用String，使用StringBuilder时，全局就会使用一份状态变量，就需要恢复现场或者撤销选择了。

**「回溯算法」强调了在状态空间特别大的时候，只用一份状态变量去搜索所有可能的状态，在搜索到符合条件的解的时候，通常会做一个拷贝，这就是为什么经常在递归终止条件的时候，有 res.add(new ArrayList<>(path)); 这样的代码。正是因为全程使用一份状态变量，因此它就有「恢复现场」和「撤销选择」的需要。**

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        //标准的回溯结构
        //使用StringBuider  
        List<String> res = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        
        dfs(0,0,n,res,sb);
        return res;
    }

    public void dfs(int left,int right,int n,List<String> res, StringBuilder sb) {
        //end
        //或者    if(sb.length() == 2 * n)
        if(left == n && right == n) {
            res.add(sb.toString());
            return;
        }

        if(left < right) return;
        if(left < n) {
            dfs(left+1,right,n,res,sb.append("("));
            sb.deleteCharAt(sb.length() - 1);    //撤销选择
        }

        if(right < left) {
            dfs(left,right+1,n,res,sb.append(")"));
            sb.deleteCharAt(sb.length() -1);  //撤销选择
        }
    }
}
```



参考：

https://blog.csdn.net/lw_power/article/details/103795299

https://zhuanlan.zhihu.com/p/93530380

https://leetcode-cn.com/problems/generate-parentheses/solution/gua-hao-sheng-cheng-hui-su-fa-xiang-jie-by-cherry-/

https://leetcode-cn.com/problems/generate-parentheses/solution/gua-hao-sheng-cheng-by-leetcode-solution/

------------

- https://leetcode-cn.com/problems/subsets/

![image-20201213095211723](https://gitee.com/sunnyzq/my-image-hosting-service/raw/master/img//image-20201213095211723.png)

```java
78. 子集
给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

```

```java
class Solution {
    //回溯 + 递归
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums == null) return res;

        dfs(res,nums,new ArrayList<Integer>(),0);
        return res;
    }
    public void dfs(List<List<Integer>> res,int[] nums,ArrayList<Integer> list,int index) {
        //terminator
        if(index == nums.length) {
            res.add(new ArrayList<Integer>(list));
            return;
        }

       //not pick
        dfs(res,nums,list,index+1);

        //pick
        list.add(nums[index]);
        dfs(res,nums,list,index+1);
 
        //reverse
        list.remove(list.size() -1);
    }
}

//复杂度分析
时间复杂度：O(n*2^n) 一共2^n种状态，每种状态需要O(n)时间来构造子集
空间复杂度：O(n)


```



----

## 实战题目

- [https://leetcode-cn.com/problems/majority-element/description/ ](https://leetcode-cn.com/problems/majority-element/description/)（简单、但是高频）
- https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/
- https://leetcode-cn.com/problems/n-queens/

